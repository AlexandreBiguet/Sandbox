%!PS-Adobe-2.0
%%Creator: dvips(k) 5.994 Copyright 2014 Radical Eye Software
%%Title: test.dvi
%%CreationDate: Wed Oct  1 14:04:39 2014
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 596 842
%%DocumentFonts: SFBX1440 SFRM1000
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips test.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2014.10.01:1404
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.23, 2014/05/15
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  0 0 moveto 1 0 rmoveto  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.06, 2014/05/19
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: cm-super-t1.enc 0 0
% This file is generated from `T1uni.map' and `glyphlist.txt', `gl-other.txt'
%
% LIGKERN hyphen hyphen =: endash ; endash hyphen =: emdash ;
% LIGKERN quoteleft quoteleft =: quotedblleft ;
% LIGKERN quoteright quoteright =: quotedblright ;
% LIGKERN comma comma =: quotedblbase ; less less =: guillemotleft ;
% LIGKERN greater greater =: guillemotright ;
% LIGKERN f f =: ff ; f i =: fi ; f l =: fl ; ff i =: ffi ; ff l =: ffl ;
%
% LIGKERN space {} * ; * {} space ; zero {} * ; * {} zero ;
% LIGKERN one {} * ; * {} one ; two {} * ; * {} two ;
% LIGKERN three {} * ; * {} three ; four {} * ; * {} four ;
% LIGKERN five {} * ; * {} five ; six {} * ; * {} six ;
% LIGKERN seven {} * ; * {} seven ; eight {} * ; * {} eight ;
% LIGKERN nine {} * ; * {} nine ;
%
/T1Encoding [
% 0x00
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase
/guilsinglleft
/guilsinglright
% 0x10
/quotedblleft
/quotedblright
/quotedblbase
/guillemotleft
/guillemotright
/endash
/emdash
/afii61664
/perthousandzero % PERTHOUSAND ZERO
/dotlessi
/dotlessj
/ff
/fi
/fl
/ffi
/ffl
% 0x20
/uni2423
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
% 0x30
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
% 0x40
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
% 0x50
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
% 0x60
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
% 0x70
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/hyphen.alt % HANGING HYPHEN
% 0x80
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
% 0x90
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcommaaccent
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
% 0xA0
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
% 0xB0
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcommaaccent
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/exclamdown
/questiondown
/sterling
% 0xC0
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
% 0xD0
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/OE
/Oslash
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/SS % Germandbls
% 0xE0
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
% 0xF0
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/oe
/oslash
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/germandbls % or /germandbls.alt
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: SFRM1000
%!FontType1-1.0: SFRM1000 0.3
%%CreationDate: Wed Sep 12 2001
% Copyright (c) 2001 Vladimir Volovich <vvv@vsu.ru>.
% See the file COPYING (GNU General Public License) for license conditions.
% Converted from METAFONT EC/TC and LH fonts:
% ecrm1000, tcrm1000, larm1000, lbrm1000, lcrm1000, rxrm1000.
11 dict begin
/FontInfo 6 dict dup begin
/version (0.3) def
/FullName (Computer Modern Roman) def
/FamilyName (Computer Modern) def
/ItalicAngle 0 def
/isFixedPitch false def
/Weight (Medium) def
end readonly def
/FontName /SFRM1000 def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] def
/FontBBox{-189 -321 1456 937}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052BD0CE60552BD63101D7CDBEEF5B11
69C468645FE4ED1AF2541AA0770C1DCF81623DE0ECDF49F2B522618F650CE6CB
CC8C21885DD61AF8A523AA677EAEDDFA51A1F9B1885EEE0456196D634E04EF89
F17499DAD982502ACC349B9EEAAE4A71A73D1147318C60A8BAC10510DE90D8D3
F46E47295D27129A5AFE0C65E22BAD10D06885A2EE623FF8E1D90287A083E00C
EF25195F68A2A98170E48759F267FE330B57DF626EBF73D2779A4A6B462AE6E5
19E5878939A488F2FE1094A76925CD24DAD4573AD3CF34E426708CF06E7EBFFC
BEF5595408106E2189F418D17AD510ED5B6A528E8902AA3A5F0FF52AE3DEAB07
32F06B63E28BB88229E046F4FF8A356BBDDE82DF2A197F2E26CA00D5594725A1
83A89A36487EAAE1AC312C929CDCE50722FA6C596C261E4D78D6C6ABF77F5CCE
0E410ED74287A0F201140F8D9674A7AC585D3CBC72CCB824F9E1CEBD08AEDB3A
A4015CADF471F7ABD9B0F0AF73A8274FD441BC1988A61799856E4770155341D6
516CD0E25BFA59B67AB7E0571DF3F5BA70AB52137D9E6A79EFADBE70CA05AC8D
991D0895C8FFC747FBC0E9A7212BAE6560B9E2B64FFCC58112E64A3B4CF7ECF7
595F51C34AD1342F5678FE1E62EC5A389CF04E82B5F832914B91F921F30A7E32
CA3919F57A2D9DE844CAAAC0DC751C255C9916595E8C9532E7A0A84A0AEFCACD
83EDE059FD06EEE9951473180B517F25F609F347DBA012AE9F004DC3C771777B
BE812787C3C50315D67254A384EB65F260943C6E16B2CDC64E15EEEDC67C5544
8ADE9981A6867405E46222CACCEF79F9DC8674268BBBE1EFEC2187A75FB7FBF8
CB2DB2134848DEA2F9CED443DCF561E7272B38F830871B2A5196A787924EF556
4B7E9093ADD414ACBC10147944D216D35007E738742FE10BFEA9C9A44B32958C
627546E24AE2CC98146A855899F1DE9E2C243D7F28ED966589D9CE396612AA26
9078E2173AC40F568487BDF1F53BEA5827D336164E2819B6AB69628F857FFC86
938F1742C86CEA1DBD68301B2C84B62A33C8268A6CCA6339F4AF79983D5172C8
A479CE8AB6CFE5FF69257E42AA6B4F5AF414608936BF5BA647138A1D721FA43D
1D5BC07CA7B7B4F81CECD8C39470B9A1A8866990838A8596254E9BE0AA158799
C8693B387D1A561C785568F015367A8CB272680B488ECE13872093FB64AD9FC5
5AB3C2B84306176F7AB5B17F4D73B66A519CB9D43F8166197D0F5988EA6E19FC
AF5097D67BF30E87D52A523953478E98F10A66B70E9B262C6907D2DD0926ECCA
D6D045475206CB2889ADD3236B93BA8CDF07076529679EF111D73E1B5BB4E67D
6BE2FFFA9D1EE483631466C29A9E5BDFFDC394A6DD05090D2AD76EC405B062C0
A63C847DECFCA7EB8C9544547AFBF3A84C5F9174B2FB78175773786794CB8BF8
74AAACC793769EAD5149144B93BC6265F469E3A118ED153CF2CC4B31745A01FF
A2B6EA8A841B3D5204460E0324A728A44706575506D08B278CB9D895318B86A2
52F8FCA0F5E5FAB4693453639318D5C02F31A161D538B2A2856AEF870FA38042
BF9AD232D663BE4CEC9D9A7E291447B91960D312DBBE9C97735B765865CE1F37
4905D4192E141233CD8FD1BAB44E9EFDF217856B33E3B857A5E9FAAA0FEB68CD
49F45BAD15222735399E9271263E09FC1493C960EB66639B4FDEE1046E845E5C
8F06FE63824D86E19365A6FBC83CC5B4606AE51EEFBD53D8605F508976C11406
E630C62B20570898CE57EF72C03E936F666762EC501537F65F5CAC2B89ADFF4E
0BC424BB943F10715FA959E9F319E7737B8908D28EB2D6CF6BBD036B37A19BDF
6A773E9555DA07C374F7755F3281803F22AB670A2D553D7CB133CFD21873F8CB
4A1C2D702C2275C4D3180812D91F5D81AF68052B92B362255D1C44A27ED377CB
612A8339108F0636CB02590F66F8B14C146845BAAFEFBFE4CF335AA573D2B9DB
FD935263022FE12D3D45BE71F028E601051F0857C29192867A15831F5034A3FF
831081270062B6B6B0B64029FC0122B3ADC7890F16D8A5685D58175EEE871708
6684BC2D4F757FD2D926E994E8E1EEAC4A14BE2829A55B68CFA4E2EDCAD61976
E7D3A90E401AB64F51DF590F682F24890DBCE037952AD69AF7357F95408FC983
6182135BD489B276580E5ADA5CFDE66638344880CC6F85A6E453112DF5FB249A
07431EAFE27409C5183133C083CB2E4949DC2D2D1ADE17E43F801555906372E8
7B007B8C9A43832B2899C898AED6EF6FD626F70582F9B1F79FE89BAC517ED725
DA0E460C5413CA5F809044555634A74681A192E2E22BAD052619A6D956CBC6C5
A5418D2B1578898052C66C8A8542BF1EF5EEAF0458BCFE820B44579092A4CADC
9A15C7C7B5CEDEA451F831A2E3D238EA59C3B5CFBC6677F11BA3ABF6FCE3B0D8
CA258B661FB6A99122B82E6DB9B5C63F50644ECB46C1915B6A7715D90BAD865B
291D4C286AAC333473EA1C46FDE77496A505DB0F3A64DDE6524A78204BD75A52
503CBBC097A9100D21325104D38302E0FA91517F04289EEB213DF0CDD241A5B1
A1B1FB7ECB0E71C1237B1F812154063EE2ABADA4E4A2A4851435943C5EEA16DB
4958E1EFDEBB3E382BC4E3AC5FE90D0E5A96AC740FB2BC843D96917A6A8852D5
B7C3BAF6C95FA301B8B561682F3D9A7E7BFCAE7C793CC44311290B09373A7694
DF7570E2CD662966EBD674F2CFC3892E2E5BA4BB7D31EFCD46CD7D374765AC7E
6D669CEDAA96D6B4817829E999206643B869260246FD78C82B860FF9CCF8588E
EE00F68A32D10F0E0703FA58FD013D9EAD2D88B01654F4C983F4C702ECDDA6D3
E10FFB63DDAE8346CD67C5A480E0DA825FF25FEDEF8FC4C3E129DE59ADF30352
8479B0D37A4E26CD6CC0EFA499B70B53E4C056DD53F8E257E4153E84CDB90F99
347E6C4A959298984C777D093078BB81618191B0C2B5DC722444A4FDED35FEFA
CCA51967BEB2771D9E8289E6A9C16030EBF4BD48245FD0D207995E8051972F26
315BA2F314DA2144FBECEC13A096DA2EF42AF598EB9149B3472B527070593E26
4BAAB6166EEAFEA964BE97FC41680B65512359C85D0FEB7FD431291F035FD5AB
341382BA19FFF3F800B2F2B8CB97CFE73A97BD6F9B93D940C272D098C01DB574
902B83396DEAFC24FFC366A0F300658FA9CF48470309EF0926149EAF81BF6168
52BF40CE8672A37BD8F6B68924532F9B5B95A4D9B7310834A0C6D2830796B21D
3504F8843C0FEC7288B07A51AC9DB1A5444DBD6465AD69F3E231D1BB051973C6
5377B12B319499E41D93413B74C2647D89714F48484F1C2A17F12C3CE4370CA6
3D787536209011AD3260FDCEC2B6116127DB85237C72E0CBE24E9DEEF3318B83
B5AD48CD48B81D2C7BE554AD7B9F50285AB74126AB5C7E7BF7556B7508465EFB
ADDE9639FFF6D278BD02F1E98212003B09BB6C65EB3AD188244FA98D9BF0A921
13C51CFC8187A4B6803956A241C22B5B70565CE440951637EE163A3CCE56250F
39E62D7D5AC2AD921805C11F33D55442F4A3FB51F71E20BF8F6C105991421BF3
3B16E082352A5F5D446E5E92E7E070442A67F220C8A485CD0B5271305E4A7149
81110BCB0992EAEF5EF11B64948EBD5314D156957A2CB416B920AEE0A9B56209
50FE8547C8541319BC6B8FDA91AB8AE21C90BBBD240BABB8D9FFB9C3E85CFF50
DC797F9282E015B6A1F5E401CBEB5CF9DF4029121E495BF6AB73E5C50204E882
53C97A2F5621EC6DA8FCB73FFEA7EAB05FF4248E645AAAEC5692F3A9206A85A4
ADBD8F38176EDD4E8FB0F8B35B4445CB9C354D0B50C70024A354D9F3571B3889
F9FF0A04183D9F859A3463B38C02170EEA1D0323EFCD094F57C71D65F0AC4EBF
2F99A4729569577BDD6F53F4CADF45B32EB9EA26AE7D8966109493962910D460
A83CA5F5C34F34E8D61AB2168B3D1B42607647F6EFF89C97B71EA1A95781E2DA
5F3ED9961EC07C6CD7373A348B6A4F413A566B7424AA836C2B4F5DE945CC8131
299C8BEE0CF718A649C442A3FDF75069DCB7AF7AA16ABF7BFB87FC8AF643EF6A
482B294D000EEB53972E2941C9968227D3AE94E27CFF99FD5FDBA5C03B5BC646
11719130A0B110F85027F2B74AB4A22855BE2B502525B65B056EE33B18F6256B
8E5F07BFFF2A72AAEA426ADDFDE4B3C92CE8034C001C01ADB378235140A1BC75
978A0BF17E7E60D7EAA6C3EB913FB9819B3642F42B6A24C32EE20856CB731CEE
DBC421CFAC4B6A5474BBEC9B086827E54329B65E14F064824A399D527D135E52
C9CF6A687785282FE377FA467AC4CBA91BDA47022F038661A6E9D8549473EEB8
F1731BC609A831C2C2E308AA8BCCE175AD81E9FC07F682D9DC509D52F1D6379B
A90446E8D5BAF95D944D8A51B4920C56EEC5F454FCD62EBDE1905F0006EBCF13
B53758A3BE19B922D16A67574859CEB0BFD28142BFD50CA5E2DB14A9C2E42C57
F6F0FE8692660DDC536B1A6CFBD3F83BD416EC7670151CED0CF6FD4DCA68502C
FD18F75D8A3DC98300E2379734E9F49C0E6F695473C5681798D28C7B1963AD2A
C7E327C3BF56576CD857E68E315C56035A8FFB69C5006B4CE01D57890FC1E108
0D905A3C6699EF5EDF6ED379F1C5B3203B46F9E302E1117BABB751E5574A611C
80F74E7FF4F7658750CAA554093C0A40FCFBA03FB3E43C5D5A034246CFA84AA4
0D9AD1857CFBB80DC662598DE8374877275BE7F69FDC1496A779C5656B3F87A0
CE1D458591A88B2F5191224388B4EB80DA5CC8EBBF9D8C3D82E14E4E60A05297
9EE79B616B0E85A05CB8C607F0E7DCF4DF97BA495C5D0272CFD969120314F8AA
0D66CDE5C5A13DEA2D839B35D9902F37303D2569DFEDF2B572384FC1EC7D7DBC
D16173F6204EC9BDF606FB71F8026DCDE132E9AE70D1711410029B4105301D09
557091914A40B179135893F2CCE85D4D2DFD652A84692B631B3DCBFF5FDAC2A3
FD2C49E656BF024EB2197FDE4374A80E3B3A61556784BED26C70760A44543DB5
E4CC2C47C551AC5760DF13030605F7BED34BF377544FD582966F7897F5314981
BF3EB429768912CE3AFD992B4E33E2413B40ED1694EF30BC568BF22D4A0AE63B
B39E0BB6BDB6C1C4998D791D5035DABF8BF4C7CA56235F280A19ACDC6EBFF4C0
080EF1A47E4614BE7C9534A06BC4032BC4458A1AE15403700E50900883CDAA7F
F5B103B7D8919E60BD887421EBAAAD56D44CB39B54D3E4C00A83496AF0877396
230C1D9DC6C44E5D5495FED4BB91EC47ED4E496076E76618BE8A70B0B58FA827
6763B674701601D12DE839C7B0F3377F3CA1141A679778341016C3839AE73DA2
EBF5579779DB080E9B6A3F3EB3E3186E61A73632E69875A6D6F55DF2EE5C29D5
5D9FA52AA206FF7393A36FC89D67687F46FE7BC0509AD3EA87BD5B92A62CE6BC
F095DA482A4DE2F592CA1D69CC210E34B853353B32E93A08187B7AF34AF7F028
031A9531C4F38A56EC57A35191227FCD198B217097785D120CA417293BF2CD61
70CC06EFFED9F2798B3A1460952FC9B7BBA1E0C9995F560307482790E11DA090
9BCA6BFA0D329043D7770D306F54B03F430FA400496A8E6697C5929DFDB2C775
C62FCA59AEA7EA2DAF74678F6F31F1F019FD475F9AD75D13D3F43680759C5753
FDE9A0C65B29FB256F0D7AD9C42307EABEB9157EFCDA78AB7D64C1490A505250
FB92C122AD7A80A7649E1A0BEF55A97594DCAFE64383E25614F85F5F786A6473
68AB4388A4E605AB55D9803B07B51D6C62169A63B79EBD284D514ADD1B28456B
4FB0FA31ACFE0B33F1EE273DD0469810D668D7703F042952BCA1277FFCB439E6
C980326593693810AE30D13361A2216E33B748CA6D6D9C5C8CAC022A5BCB5B34
CB12B7F02B47DFD98FBA553BAA8979632303497214FDD8FB047612EB8C53B96F
6DB935E2D897130FB3F6016ECCB6B1A41E8730A84DD6524A30DB69799ABB2DA3
774D18F6144CC8F1055A04409395A11702BE97D8CF7988516F5FC74311E2F250
99048CF805A946BAD20B3C411DEE774B23C14696DD7A4243DB02953903FCA10C
8365DD54442CA09248DCE1EC1C574EE6893AB1967B5A04C5D45FA5A322D80EDA
1C26ED3A816DE9EB8762AC1963F6B79AC87440E89572D2A12C9D36F7CCA0ADBB
4D53C5BC7E2E91951C4BA1CEA35FFCA2BF9A151AF35883F7C490FA1DF609553A
2900B5F1EF594466035BAB154B8F3C28E19BAEFB623FA2C8AB89341B40CA11EE
22E662A6C6F745E392339F37DDC2205B49518B3F9F1D30B9BF6061C968D3941F
834E31EC43C4F74DA0684206A1447C52A30C9A56515F282602FD48EA3FE69F63
9189365E4CBE015BF312EAEFC00D900E8E943B88680DB34F5D02D46BE60BBCE5
2BF6DBF5EDF9A345D2241F9275C3BB8C1E95E0B76A9F7B6CFA6FCB9D760D3090
9DD1775C4EB13BA3B2D60152864BE7EB0A8F8C6CD39B5C3A0E3D76B433987B22
96E13EEA56F869F3435CEEEE1F2EA065FA8799B99D62BE9048C4D6E9ECEB19A3
5AF1481F83BDF57CB889915B31FAAD0D9482CF1E202BC9DEB76C265EE87BF0C7
8BD17C233E45C46538F6B14D6F0F7E9EA944138C5412823CE2DE12E25445B5B0
BA0C2848C9192C629823DAC367C7C1AF6D1A0844AD12B1F961F50AC58AC8FDC2
447A8DA606F7BF9657537DF1D18599AF425279B00C9F230432515D73289055E5
3B24FEED2888C0FCDCEFFFFA21299C8868810D4EB71D637BC0CD4D646F36D218
2564CBC6C00B141A758934A725243AC78AFDBE2B44BF239203C7C33CB54E1A7C
86C1458CD28FBB7FFD50AC3F036BF62316184C4DB09DD50ADA863FC89F4F0323
03DE41054B612F941F8A3C6E1D1301EDEB001851A2D63B302BEAB4DCFF52EEF5
F7D21741C640E0A70908EC73B81E95714793D08CD117CDEC6F5CBEB56F9337F5
98B85751BC90F00AD68C53CE64B62648553A7A28D73E11BA920DCDA36F1BEFEF
3A673DDC442950D4FD7703ED8C4255C064E1843D354DEC56553D10D08A83F354
FC8B5AD01DA8E2D2FFCC0B417E2A86B20EB513C23B65AED241E1AD62D736B6DB
ABE82547EDA4208F9A000BFFC858E7140D47E53FF8C725AFEDFECA2A8388C471
A20CE2D9B4F1FEA56902F01E6AD1321EDC1A1377E19BE29FE17DE9159E3A4A1A
FCC5E735349E09117C1DB5FCB99637408FA4C886317967BBFDC3B0A09767B195
BAB1EFA20D2BC9102A604063ED52CCD8D9B89E41B02136BC97E2B4D1B82FD0AA
18B48BF9E6D0A06A3589E03CB1A0FF6AC6CEE53F36AE4857093BEED8C005289F
6CAEF31915ABFBD6FB37895B44E7F9AC0D226D7795B6745304CCCC0D26B724B7
5A212B0C993EFD75D6CE49A0F38044BD4866F3D7D93D078DC46317E5A5E68026
9D19302A9052A7AF946D3B1CA8E2A8BC13AD0FAD9BFD35391A4E564E7FE1F902
0A2EA8744C5E50BB3C9470E1751382871876B0716DE6BC5E10374CF52D90520A
343E2E8B10751759BA48EE5FF547F7A7C29EF7484128BE86B52C362440D67A42
531D96010EEB9E7B32CFC272BE2C0A2AFCF312E015B264090783923C878801F3
251B3742FA390353C15FAA6F7B4267F6536E38A3B38CDA5F14B7F2355EF3F598
4F0A6D0F2F2EE0599DE870005977FC252F5D6E0891DA51C599E10ACACD6F9A07
B3684455F879D8AE5E6207B2B71655E83CAD37A78321F5101B837609BCB1D3BF
C7614952FE4B01793262E820E813949115DB90A7C40D9D8341AAE6DE18E3262F
9391A0ED0E7F2D13BA604600D5F023CA0C3F42125A26565982B4EEDE885827CA
26DEFD56279C687C755EAEE72CBFE212137A07EEA25168B07A94906FA355324A
AB6D450BF0B3F3342C6C897D172636D743A4D33F0BD5B5C693F73780AE7CD20E
45EED728A8A435E130519E912B2918120E0EE9275500B1BB08CE4B28C4373B71
A68E03B5E5CC81309BD22D737951BD925090B391755F8F6DCCF1D50321133F9D
E22E271495E2B761B89E682DF63665420AF736A396DBAFEDE0943D7088FE3ADC
C2931058DE3A29F152078346A0DAFE9BBDB7BB16431A28B681D114062F458FF4
3F071B02963883D71B3C164974DDAED8D00A3AE571FD69839BA984A38BAEF612
6D47E4E00C5CC9992853912F5FB63901369DE7A3DF57034BF7D530874FC3A9AD
AA2069A157A03086B89368C647D2D0C66972629414ECB8A5CADF831BD5061B48
A05336B06CD0E30161673A6F51D03964DBDFE38C6ACC76A99D5E8EECAB65672E
D471DFA741DAC94750B605510C8B5DB66390BD981E4801D8B181EE28542CEFA8
7A839D70015EFA7FFAA12B2569F950BA6EF00D5CCA7C13187CA8EDC2BDF64987
A92834594DBE1286FD7FC66E06ACCC9BCB09D831EF664B5F92586FEAFF2AF043
B7262FDEDCE72EE0C81515D2FB653AA5BC47440F392091AB78FEB3A5B2E992A8
BC3CDE7C27075C258B458675A908882A7F1ACED79BF850D5C61AB2FFA42FCA71
09148367DD88969FBA58F8B07823FE0926718FD377D118D4521266339AE1FC4F
F99C29C798D3082A16DC573B59817831914090843BCAF94E0C4868EDFCE51CA1
B3B88A408FAA0CB73C7E63D6C13840CB92BBA1F67D1D889702BDB306E1699CEA
86AC2CA7624AD50EF959B520F36B815D1055A171630EA0D1DA71F7A677F5C0D5
4167E37CA1A49A7A8B565A467989444477851F68D3900AFD7B9F79EC93E520F0
89F0B98EA502E0B4D61A3611651A846D4AA99CB59E42BEA3B7CA2508355C576E
1041C312E08C2C8205C135AF45D1636C8D6C9378E4CF39F4CF139859A5F8DCEC
4978DCA24D276B5A3B363C8BB499753DEAE0DD43F98ECF31D6B1FE240AB64322
774340B005271AB557F5843880349CC74C4398395D60A743289B5086F392CDE3
A0E93D890DD7F948BFAF8AA179E6D77DA6D918EA507178D7D4994219F7E089DB
937DDD11D6091005AFA40DB774F03B570D176879F7154DA77DDC0FB249F02EEC
1C0F44FDD4DF74A8F5AC3AEA8B2B5D407E5D72C3DCE8F613C8A8C8D487D81902
B12D1B449D3D8AD0FB57C6E900854D9BEE5E8EA86B4C15D3822CF62638C85A25
5EFAE26E63A1998FD53CC14CA3A6AA1BAFA5323EF5A6F036044D9FCF9F08534F
0A5F14037C97CA7C999477C368E35BB4BBD8AC410B6A70C480D0978B16920271
3C3BA47DCA49F6C279E96B2218A35BCD80430D9888662A8DC6829F4B896323A3
64B87A2F69FA29BE10097E832F7DBE008CF0CDA01E9773229C002274EDA6D595
8092060CB8D40DCBBB848296DF7A6DA8AE9C4E28C7A6553B7944D6A8522C4DFD
BC5BB43C615098D28837D471B49CB239B1BF4C4D4D9525E0DE1E32C806C11B49
24382B0C84B72B29603D765F290CD789B4599C2C811F1ED8DB2B8C9CCD8237B3
193CFB569FD83C7F107D24524DA2D8B6DD2C989EB8E80A77ED627592DF0BF5B3
0EC9DC1727B44E0A07EE0946033945977CBCD11969C3638F0B8FD51EDA3311A5
EAC7876006E6C71C1F5FE888E50546C187C5F3898B654161C3C3EBB3655EE4A6
38C848C9ECCC574171D2E2380125D05A248BE092FF221F3A9BBEADD9216BBD7F
A64604B3DEF3D928C7CDF7DB422443EB3A0D86D29E074247A41AEB55EC17EBF9
6D17346E07882BE476D2BC9844124859E9992E1862657C39184EC7C44F4B200E
E162516DF65506CBF184D8534305FEF1424B7289F2C2F55EC61AEC24C9D1D083
F0807CDCC07A5CAC7707BDE93B79046EBAC01620CA8AAEB267F221C6CF77260E
F06A365176792F57054140FAA50D3B0EA52186A8A741A1D4380DF435157BEFBF
0ED24958794624759ED714FF0C1544F7DBBB387CAE5536DB93FAF8487F909BEE
2C332184637C6D70C30B43B5CF9AE3433EECADAC14486164A33B77EB28FEA789
DAE02E1E111AC732FE5CD1012B7FF5B24A4407B1FE221F7AC69D63A2BE192466
E61F6A154B5490DAB4A9663322EFB07E746484E141767392188E791657C5E95A
9239F450F947345D17D90BB8AAFD819105960304351AD85E513FC96FD426ADED
6354EDF507DB06EFB0EA658C8BB454022D10F1B8A03CE1002263EBDDA00F4359
66A0C4826515D0226F5A5AD43DD5CA96475CC6DFC997B78F9BA1F7CA911F25F4
2C60B292811A5BDDE4319938DCB4B04E59987BBE67D93B1A101D5656121CBCE2
EA64C3B05B1B3AC68A0B8A89800543E31C55A167CC5938965D4F6C75CF18535B
7FE63B91DA5C91C5C213A951CE1040D23BF15CA0E776EAD954C29319FCF5394B
D88C5C3414F518EB56D764B10B5F14F2A77A1D3D46EE22BE0725E3C0DF14AB47
FD59EF26ACF6ADCB86762F1EF45FE6CD98BCBD6A98F0F9F971F042D98510B6AC
680A8F6878CC909C6874CB617DE4AE387F1D4C15E4B70C8F165719D9BF149210
10773C400E755050B5ADE97B3C894E6CD487FEED3555B09A42054A1D417A9239
6BBF2698701732A6D987A90ACF64BDFE8E38A00E89C93A706AAE75E6ED86EFEA
F68046A618D8F66D6710817036DDC3A1540090F5BB2B6DDD4DC80EF4F526D49B
5CECECFFA98DC52C5A8A969327D847AEAE2F548DCC1A9B6F94F049EDB8A8D29B
BBBE9026B2C518558C4969947549E138F519E42A2903384C57BFFF54E7FBB1BF
1172D9C222DFF2851D19180B78C200B9EB39A15DC99272E75D19F2562444FD39
38F893249B88C6181A6497429C542FF8A3273BB4C65CB786E5F349D306ED11E5
CC53E58A4A870C33E1BB2D71348A9FF4DACA0EAD53E0EE325204D7621C78FC5C
E6CFD00C25561BD155181FED2B7B34262CD2F43A0181F1E8F7D527DACF0F1B6A
4470E352CD32658678EC2B095A47FD4DC55427E61B9B2869E86AFDE134B1222D
03193CCE50E1E3D5B3E47BE464A4EF35A29066189C6177D8FD22BC7F19741338
FF84EAE5874E7E5957E72A837B110CC04BB65B787F0CDF6B37AE45344F5B644A
CBB0F7E0400919B09B49B3AB14E5F0AD698FD1B301BB23A99F4009138AED6BA3
529556776BBDD9BFA0F5CF51A673F06A33F2F176B2A93ABC55B54D75DEEE57E4
08AA39534FDD6D41CE9DB692D0495AB61028D3AE2197BA3C3EF8F0FF4F82A8D7
A894894A3D597F3697B03A944C47E0081BDD411755AF2DC345796AEDA5C96057
B34082F77E30F730DF83CB017D091F21FF313C6419D2C8F24F11BA62B2822936
F140D86E1163974846ABCFFB904C99F034FB969909748655B78F2500FBEA58C3
7126EFEA3434E2E842EEC067CF616E84B62165BF919B7FAE8052419F03BD0CE1
BCD1E4DCBEECFE4CEFD5C3CF1B2D5E8CB9636CF31BF4C8C223AC3AD31B54F27E
41E1FE35FDFE0770F1CBC64254C4BAE891B75FC22F4C691F9E8A3360F5EE542A
617EC0A3CF4C8B8C8927F24C04F498A1C7D251C31AF3C4C9483364DFD629011F
C7430B66DE32D8FB76586F01FE26B085A411C049713F1B33B860C715CB71601B
97808BA29378369568AB99EEF1B534EA12A504565768547B24308251BC1F119B
A6B220E57E1975775B62027582FB88C242E4EDE46354A40BD2227A24D54A2257
0A50401DE96185D164182EB01C531F30E4447790057FFF60401401661BDE8FD6
C9967E6C6490538BA53DA0D163ADBF468E79CA5CCDC91EFD128FFF45142C2855
3F31DEA0E7B467FB6F19ACD68EDB5A267CCD5E540440EA91F8E3E9B220B7DB60
1E0D6F71F1B26838D8B7505138CBB18115723D370DBB23D5F6D04DAB2B86BDE5
448E51C800DF106A9747916A9413229AE3B6EF4F31D113319D95D79BEC3BEA74
1499517D15D174B178494432E4D37B62A9947794ADFA50EFD7E802FE062ADFAE
0E80908401E4B430F678DCCC081319936EC8D52BC8191D69FD489E5A3830CDCF
5ED3BCDDF2E772175273E6AD3DF7B7BA6C61D8C629C759D6A376472C1BBBFF63
6A3D33B7F31649A1C81767411F91571450A3A009CF49B338BFECEB3DFA3ADBB9
6061C2E731B2BC2B6EBBE5859CA19AB427EEF74296B210B9C89E09FDF1901D8A
43B67E620200B5A431342A3E0F121195D1EC4FAFAA990BF193AAFD010625FC5B
1E3D80A74DD371CBF8A05F9F1957F990525B85A4FD24540AD71F747DF1D00496
857FEDC10DAECF78626648A66811B24859D5CB4DD7B8596F0639ABB6FE2B19BF
5CE7050BE209E73C0EF588E026FB33235325D3C0579DDC9E9AA34F98FAC793D3
52873AC3B4FD274604BE610F4AB524640A21B530C352A5D7930E7DBC0DEF4AC8
31E5EE62024965695C52993BA1743D5A1564B5EBFFE70866102FB3A83B177FCD
6CA8ACA3ABA4D412E765CC7BE14A8A59650C92C67FE936A339DDF18FD13E618F
4A61EC761681B051C416AE449621DB0CA88DF0AA5EA4D0EDC435A6A202F2950C
C60E188E1A09449AF787ACE34A9983B5A844909D95FFCE9DB89618A45EF6A63B
CFC4F5F6007FD89724918C962A685916594CBD0301438E728C9A652E4564EEBB
59E363822C407977406999BCE55CABEA05A7EA954D3F7FBEFA0DC1E658674EF5
C1ADEA24FB98AC68B1B268A871023014A3DDB9B7AB97E3C13A38C7E5603173F8
436C649A625B7696FE9C79E44959A9204356A8E318C2F2ABCE4D4333BE1E2CAB
D04F188274EC99771D2B477194E7550623DF085588EFCDD36869FF3B6AA27C4C
037900112151A29C08C33A0A6C2A6236A4A65BC4141653F870BFE760F73D4E8D
0EA924894E3564597A9677EF989B49B3E4B1C1CF06541DFF4217AB63BC619C10
8FF950F39856A28F70EFA906E9751EF2B6FD3A2C147B15CE0A37CF54D18E76E2
E802B6A90C5AE4E1D76029E9A9334E42F05DDF227D8B2816914E0A78CE7D17E1
F3AFD90034D0271C650560CA5BB644E44F0F196F34FE80249D5CB0932F724BAD
CA9B14FB5172A022AAAE0C0DDFC67FFB79CEF2E216A83AC6745C6125DC4BB3FE
3FB06EA6BCF31BC90699F63E66C4DC654C46617FC718A13AD5CD6919A6BB8EB1
88CCC8F5AA7DD2F00560D939C774E6456E9E09A9162935D9F9FF1B930206B78C
2F606F50D126EF35385FB6129B399C6238D9DB41D608C0DC55F74C67544C1A41
0EC491C6271B865BBBFB310741BBD817D6C546778FC470D50DBD104517A76989
A71D7699F312780091F1721E9D547D6AEC66D2E378A89D6580801F1FF72D67CD
BA13EC5772BDCD1E79E16AA28AB8D110B052265B4DFE796EA744136AF3FF25FD
2AC1D326B2FFA1BD776767C9FF115A57681C51BBA3143F1D25C082062B87015C
90AF8BD413B43415860FB1297FE80A8B4FDC15F10185FDF8508A932BE66B7BF4
2F7EB5021E16AD63024450EFBA512624490B86E9D9D38D42CB8F43F8B67B70F0
5A53CB7BD67D71E7BF01DBAF189DAA0A9955C13A06923C1BF2F727C37CB55516
E98F1AD4CEA0D501589A83CD2E755E22824CDAFAED83EE0156BD805460C349AC
8A4E3D1C454F7F3867545784EAB35B67622A31D16315488E4085C9E0917A23CD
422B4B8A11070876204CFB0A6C0DEB60AA92A7282837B4A9B3AF59F83FCDCA66
2A1D0727819F26E480897CEE872F480B9DF6D340C80D576F4B4DE46F125E3CB2
3893412A56FD6168C00993BE2C01AD859449A4C6A9F0153A91BE270DC064093A
9C1FE200279C52BF4D82A6A74098B494A462A2C4E43237307E00BA4799E5CCA5
EFB6CF1E96C4C8CBFC6625B5286B1D7B79D0CD5F0F28CF0A36EF5BD2AC8E542C
CC785DAE24C5518AAB2780A3AFABEC47D477DF26F1D3AE5A596696705A001AF7
E703CCD728EE333AEF116F61780393E846A8C4C709C8DF1DBBBA517C90540636
4FCEB08C39C40600ED0E3E3603A24D67336CF687D18C4E3B301C2A286420140F
C099D34F3E42D04997B3A18CCB0F81761B68F4A63958DAFEEE4DF1A2955ACD45
D3EA509DC9E49354FEB91E941B0363BF0EBB305A9A6A9A46EFA6F92D3FF5D90E
8EEC258347A7D48BB39E0B7E3B6BF80EE246C539C3905837E5214161910F7FAA
71C4925C4B608C0D15E9FCC2E17555154326BEFE373676AE97F79C36569BDE47
87825924F5CD626E92249F9E0A6EDBA22B09546297FA6DD597F055F7809977F9
8477275C6CE9A7D91559A89641EFE37A88B059062D17C67AD3A5D01763B5CAED
0B6CF0BA527DFA04DAC0778526E7146160D9D9B76E09016944FD13EBAE23C8AE
DE95399BF4D27D1C761E9A90DFA76C786BDBB1521DA107A7119CA77E7C32DD75
D66A36DC4FD084E74F7D5B873668A3AFA48CFFA6C2AE42EDDE5EA007D54F2564
82E277EF01591077CF6A10BCF1737A30AF83DB7373C310E4E6577E17DD1DB847
764410D4C791C3104DD7767B80B6F1715A784EE5E6086703FF9D02
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: SFBX1440
%!FontType1-1.0: SFBX1440 0.3
%%CreationDate: Wed Sep 12 2001
% Copyright (c) 2001 Vladimir Volovich <vvv@vsu.ru>.
% See the file COPYING (GNU General Public License) for license conditions.
% Converted from METAFONT EC/TC and LH fonts:
% ecbx1440, tcbx1440, labx1440, lbbx1440, lcbx1440, rxbx1440.
11 dict begin
/FontInfo 6 dict dup begin
/version (0.3) def
/FullName (Computer Modern Bold Extended) def
/FamilyName (Computer Modern) def
/ItalicAngle 0 def
/isFixedPitch false def
/Weight (Bold) def
end readonly def
/FontName /SFBX1440 def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] def
/FontBBox{-218 -316 1652 915}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052BD0CE60552BD63101D7CDBEEF5B11
69C468645FE4ED1AF2541AA0770C1DCF81623DE0ECDF49F2B522618F650CE6CB
CC8C21885DD61AF8A523AA677EAEDDFA51A1F9B1885EEE0456196D634E04EF89
F17499DAD982502ACC349B9EEAAE4A71A73D1147318C60A8BAC10510DE90D8D3
F46E47295D27129A5AFE0C65E22BAD10D06885A2EE623FF8E1D90287A083E00C
EF25195F68A2A98170E4875AA0E2F461BA16EADB32842B6D00C76EFC613FE56C
378A7118B0589B3EE5425457AE310AFB3829876138A59F58D965843B709A0F4F
D1AD54875BBADFC803A755669491D9E98262991B9634084E8E2BE46EF805B219
D18DE35ADE9A8DBAB7AB761864BFB6A27E5B421C32CEE4569624D9308A32B426
FCFA5CEB883444393CD7A58F9CD522BA73E17492DDABB7E00B2F6BE47F585EB7
FDDBFF33F1B5E5465287717D1580105BF3929C09EC621CEE9606EC49D7051A00
11935EE728A2FD47BFCCF00C93EE54910F77C1CB8622B9CA129D466746BFE1B0
594A9F0C785F6CA67161EA1480AD4EC6781B9CAE9536F5D3AC6D447F16821F77
AE2705279CF3DF4E1E9AED81A0CBEFBD61808E2D59AD970264A5B66D1F399DA2
55BA0AAC8EF1A1E16FD8240D577F5E00E0040EEBCC193F074FEC48DF30882551
E23D64EF84283F9640AC5F60EB1F26CDB79078AB0C0D97D1D6297D092380D4B6
6A2099F06A513A78A3C3B82A6DBD985A0DCED7150B19FA42991A3D408FF95978
15D309AACEA8C5C0AE812F50330CCBF47B4759C550D49173127DECF05D783DB0
978A366ABD3CA7D9BBB6652459A5E19F9630CE75C2BC7BDFBFE0EA3D8098CBB1
98CBE02F196C0A0C5E976DECE72778358CF8D0A79A8B5629A6322716CBFBDEE4
934E8782E716185235712845BBD03896BAA8126E2E114F06AA9A0B2DEBEF4281
1D4D63D49BC7C89CBC8170C17B5CE694EA3048E3B2431BFCC49BE06BC16267B3
3547F30851E3F7441B4DF4A7A4A0341CDB439F8D4CB53BBBCBF09500FBE703D9
617BF4ADE275EDBFE0C8692AFBFE06D320227474097847EC062917CF1B3F675B
C31AD512EEECFEC5D1E4B54ABC07FE1B9315946BEA6E4224FE51C7D95DE4A9C2
44845DAE8BEF77E829EB5FFFBDE155F7118DABA2710058926158DFB7A533AFD6
90A5EA2C36FC3CD9E2FF4118D9CE49F33AFA3CA306FEC9AFB59E5236204EC76F
7A3C6349DCDDFD47AA3C9CD34C706AC27CFDE15D9E907FECF478F490F54800DB
2C646DDA53FD1F267F5875A9AC8DEC3DF640D3C4C0A748426DBE619DA65C070D
9E7087C2755D41C6192EBBCEC15F12A4F8D9BE40B40335D2279A457822302488
31757D9168908F0B8E1952D8097633836D649941EAF86B33F38B8126ABF30287
322376ADB39E56E5A0FD3316D513A048F34512336F94DAF510498B635624B631
DD11B651016B20B867FEECF3A82AB3B967D549895AD2EAD722B6A3BBE8999D9F
A5A6C956FB2938A9F76ADD0BF43207DE7DE70802B98B9C81A16CEB19B23657D3
4685F351CC0D93D513E044CF3484D2F55A8DBBF434C5356276597C5EA62F5A4B
49DE2FAB14BD90C887E7FF33A06D9F312602B8711E6F7285D52F30DF1555B26F
62DB50DB237D0E6DFD301833855FE2427336FBA63171D385F2B42487CB337993
CCC0FA8B58D6237E52C61F0A22DE454F58801D5D00F150F6E6E69CA0E60E2698
82099301160C3450D2ECB2A8DA999047EDD7D4E25ECA50FE1EA1FE7C727B7E6D
D384F6035F04FDB35F1847A262C2D2385181E3F22BE45C2D6F1BA1D5C8038529
CB897DDD5B686826B5E89D7F005D597DA8D33C583E9784E90BCE05BC014C9573
6F44FAB37523E4941D0FFCB7BCC8D0C7369D870BB9976CC89743D9892CF379FD
8E3F1F9C639D860F9B4153AD3E106366D0B0064EFB9F8B01DC9608D9734D002B
66FD97AA86AEAB1BF32AAD0BCC80BB64F34C4D4BB7ECF5DFE249B29422A367E4
6B329F10813DA0CE1F394EF8AEDA1D0EF54BC676F41C5E45B3DB5FEE796C5083
512B168BCF1ED1E1CA061D66E7D2EB22BCFE8F1C5CEF74EC07C6D9EEF1911CAB
F3F0AE82682B251DF566D1EA35510029E1F6D3966CD6DB3BEC3E2D09ACAA06E5
907F8C9B1450BDEAC4AA2C54E46C2CAF59888C8509D8BD1E3C562DA6A71D08C9
DCA5C2B21B9A97FEF3E40F90713D4646CB913A984107090BF34CFE75D986E626
7088DC760225ED905D995DDBBB7205AA2A41A3CE4A3F375E7C5079B9D8FCF57A
797B5A4FD89A01934A2E2463B895CD19385C95BE2E86F99352A6DBB5512C3566
10B624CB772482920515BDA8A8D227D42050A292E989037E08EE4B66AA9EE009
B340F669190010DE80FB0750139C33AE368BE204681EF627A2AFDB8DEB5F1873
58FC661B65E3AE472317EFEFEE9C9F6587E3A5B415FDD84D1057688110340C2B
BBD50F0541F1E48A71BD373F07A51BB82EA7D1DEE101693C94600BC8D8854C85
CB053934CBE11F8DAE3CFCA2284643AC878A542DEBA7326300266E6733368FE2
ADD0B52AF04530708DD523440B8A2DBAA5A34108A018DBFC1FCA6AA3559B40A0
A0F16AA8317DA3CC28F936D0930547609A2CF40BCC511B0EE9FF31BEC789EA6C
73D669CF94668C6F1CEA5C28660640D7E17834F1C75FF76DAB5975CBB71BBF81
64F6EB0178018466DB240C916D04C885E161DAB614185F1634094D23BD188CE7
4175526415CA118A1F4A4749D1A83F4B69CBD26B5A0FD680DDA0668CDBCE4FB7
2BD11F17B6187D9C0F099ED62F76E7BBC0581A708D05C1DADAE38C484E22408B
A5D2BDB31A8646DEB041FD2819B1206900152705ED49D981E5B0F80735B7B7CF
4529F6CEB39281637933F587B33656524DCF4234D167F6AD72D7F7F88910A6C3
C2D6EBBBD5813BB11DBFF5980FFD9425AE6587B653647EB6D77A2302A5B81A32
6622C31D8B7BCB9D118DC089485C5F41E675B238AEFC6CE2A1D5A47A9DD001D3
BEF8D09021E4A0527BA7EF59C0A3B8DBFC77BE04A4516DD56365D20E5992F5D8
876791BBD2A7EF4C9B30EF408FD89D2CA2867BB4B68A580366A667CF7FD5BFE8
4A48B47391B1AB66CFE6CAA5466367A223B751CB40832014D114AE1DE52E3AA8
0BA1187D12E7BADE4F0B32F739AAD6452420E361406209792057285716842CE9
729CB5900FABCE2B6B54472D06D792519BB6F6A7A22B1E79D2ECDEA8F1697B4F
4B5763E628A466731CE6F47CAD868DE52FFDD83ADE45D7B5398127574372E240
3C6770C35F4AA4AD0D7458B845EA77F80E8303D12FEAB7D1BEE3678468BA9A42
D73A7ADCA675F7AB542C1FFFE3D0F77F7C2C9DA70B8D47EF7A5512D6EC950888
E7CDC0DE2D416965AA09228A89E0645CC6FD8E0C586514E96AB8FE3E73451C96
75B82E197003EE8F207F548C92DCC4D49B163EFC5F1BAFAAE6AB8DD58516F542
91575AFF71F871A10B59DC915429233706148979A8B5AB0FEA0745448481F15B
64DF6A6F8FAC8D0F11EC84215B4AD28C78862017B2A7AAE18B7B3CD1836A37DC
44EDA5CBB9125BD7F4AF5770DCC8A33C8645359114E9D71F477BFD22C6637D02
21DCE95F0E420DCEA4644711BAFF2B2FB982884653A8E6819D47B50B6827D2AD
139D86379613F0C6568FFDD010BD70620D97B5169579361BBA8D8DD59C7ADB16
5BBD4FFBCD0CFBC0D6BB31A72852DF1F401565810B06275F3E90EF3EE62679AB
A920CA26BA1118B4861C9900C092C3CBEF7290AEC8B462B3039DC126314700F2
4E73D8E403D916A7D13AE20C8CB226F1BF994B6B4237A5C89310DCFF7AADC801
637F88F02D62476AB491C4F9F0FE6B3FAB7D8BB9A2123C19CE3C02EE865408D7
DC3A930D9B513BA80590C0731C2404C78744582EEC970D93A241EDD719DA6285
3EF535C720963A7FB379AF124F358C68F6BA822D6591C731C7EE4943DC71A995
94087A0AF3051EE9FA937B47909D95FF63941611DD8736326153BD8AF6507BE4
D608D72543F7692E2DB04E11E96413271D137379FECD9831BE0D734E85C94D05
2944B53F16E67D915592A91D404290CC5517CD9D127D676D481FF9A3F5661597
A468F428C0D3B196FC1A3F2A4493DD258C11D365ED0514155ACBB4AA96AB5018
8EB989E3687FDA4BBA7813F98DBDD9453ABD5D088CABA8D7F062204B651E83B1
CEC50974DD9004BB24A5B0A8AEA8DEFA2A72739471F9941FF2CEF471A310AF08
67C9AFE26EAD20BABA944ECF415024E914B8D258404DC0ED33B192CABFF8CFD9
24CFD804CCC64ECEA4750A3E32483F36ADC9BA60732B389DD283640F5CC82B42
C73D588F93D212273F2651F70008BBCF55F61BF0CD988B6448DDE7F29A584793
883D4E4E5B8240DA800EE9152542989BEBD49F84FEF4C2CF83F63B0D93D57C66
CE1367158F779933221D8A60691F71802D66FA7EAD71625AFA29921EB950B081
CC0D5BA5C1AA9B63C354E8017EB1AF96657CE7BFB73664306176FEC09C911970
329183EE663D1CD7D279F58F29A11E4EF0251B3742FA390353C15FAA6F7B4264
57694F2C3684553C5C46FCE745EE5D955CF47DFBD0A317729E8CA441D9A2628A
0752A5B4FBAF0CE55148E672D9E7B0FCCD2CB8C0689A9344918BBA941F87B05B
04A44635648403DD8016396A53F14E2695785E6DEEA341102F41689EBBBB27D1
6C209D48E8721F41DA2CBB3D7005220E5131EA5D4BF66EBB6A9763034716220E
340B39006E78E1E72D29DD7685FEC66BC5A81CF894930AA63874AB872E2C813A
1015427AD5372F6AA8E15CA7224952E9325C0AA330D3D122FAB354A386F91B23
E9FE68642AEB3CDEB3B476648E571101CB06C70A52BA2AA0A045D56CDE8EB86C
A997ECDC75C8394C05AC0A20E4A18E2686BDE5448E51C800DF106A9747916F9E
03730173FC1317D52E1452A70157310102B907A97144B83E456B1005E1464BA1
46A470C33F08F563F95D5C1FED40BE32D149209E7424B7D9EB0C026B33B0D3A2
166DAF9EC74E03B197865B66EEDCB85F0EA2FB5750D658E55D621FA7D5041D31
F9DB84375087566F151D852040834B10CF9143F3A1A0FBBA2C493EBEB8139295
5105AEC38EE03F434040AEA1BA512ACA2417F560AAD8F7A4C9A6BEE747332636
7FEB8BFCBFCD73E9604F28238D6E5081199CFA4ED3CA8EAEC7980FFB5E8C64AD
F8CF44977E516ECD13D6346AA353D6D316246ABA2CFFC6423C5CF3524518050F
8B3753478873D8DB835C0C0894DF76946A3C7AE3B122DCEA7B5A49AD1859672F
1F02DE4106039AEAE823A4B40357DCAE81F0A6F59B670986C6A81009D3C81A08
B760F7B04FFC09B1CCB21DB075F03A20EBAADC22DC48BDA527A3A7EEF1C85E33
5DFCA51CD9DA17845068139130E6936AF27B3F6CFD49788BE8F7D30D168CD79A
A7CAF3D4E7E3929752093805E38E2C896BB88B0A87F92D7E73AE592789802176
0FE37EEABC62D0321B8CF909690AA656952B903556C5BD46700577ABFC0730C1
308166FA521AF1D62E41F530C02FC1F8A0D1DF0DD7D3A37804B3A8524617569F
E5C5935C16918F0AB2DE1866E4A198030923C7038C89884DF1DBD0BF354D436E
3A3D6E1C289B9B87015A90D413D507373B5AE95F03B2B1275EFFE5BE187985B7
03D4931F7388DAAEA5A0AA4B9C14E7B995D1BF70FE5753C58854647DB379C4E5
71A2BE42F3D6F5144C7D2DD24979B3BF93AC22E7F613607970A7B53314049583
1F541BCEE1A932F2B581572D98F18CEEDEDE8A0BCF72AD751DDC5C8FFE377434
2D7889BC7A393D9248E23F0F6DABD35EB11730B04B2B854027B6822D0A24ABCA
FA9983962AF48FDB90389BA8283F2009A9379E3924A4CAD17999152AEB185692
AD26AA71F35135D556B67D6892DB1F1FC24B32B0207BF2EDAC4107ECDAC6694B
5C5C1EC6148404D29647F8C52B1FAC7AB634B0E396C87D8D4C6829B1B1B1A7FE
7E335469A595B53381864AFC93F64F706B3C644255D24492AC0F942BD3C308B0
17F783C29C3604D09D059CDF5EEDA2666386B72023CFB302C5B962742804216E
C1D120272E0D026B7E87234F09C3FC8AE3B8920ED125D8C5554A45816F11C172
CD416F1E4B622AFFE3B187395EF316196A3A5F1A429D632D0F4979056A18E04A
A75872B2561D3988A2E4DD2110FC33D924B3975C82CD0B104E7F9187CE30ADCF
7E712A8E2A4119339939252184A05260950E1CEE746E1717873DCB7FA9F94700
E0FCF7FF5E33BAADDAB00351610F949E13213C3C4DE232E45E0C8963984CCED7
8919017F8EDC6CAC0C8E781E3817431ED0A0ECC2707BEB48F8E46A985DD33F7A
EA70251B09EDC26146F250BF092EC5BCFD3DCC44015E2266FC409B29B9EE61D6
81403B2CD7713D3408D17A9833AD88DBD19815DF5C8D374C20F53559239EC2E9
C4733EDB2538301804DFB91962B67A7C6B2190F30E2EEDECE8D09B9A6A98301B
4CDA4BDB1E08B7036EDF70699C8678D843BAA10DC69F520D7DF35DE48432BBAB
958DF6668561AC787E9DE1CC7D9A75E9F4AA6A4D77661C628BEDB58E4B232A5C
3E69EB6D587E649253ABBD375531924EC2D0DC86C4AE40673C852514CDCF5936
E7F6C62123B2F3F6D0F3BA8FBF7285F4E0268E609587CC665D1673093CFD71FF
2DA588399B10A9D2B3F0E2A7B4E369BB60715B43FD74F3CDA7066ADF1B4E1D88
353E072D4A417B3CBD400251BF1B6D1448A1D438CFF5B5E463332C4E3EA2C294
29B292F8856E74D38961AFCA2FA1F3F255BC126BCA0004138D6BEE4CDECCDE9C
DC3C861F663350128178A0F799A6657B9ED351776A911DBB57D9D3424A03A0D4
FB5C06E94A37D77BA61F010A0D28538B61718112387FC95DF70F7101EB114A76
0A976446F7A98223792137526E7233E9392075D99039326CE8FBA82343EB98B9
B236B48E65AC638275F654AEAE9E48084A5F6A130637FC5E435A5F57BB137DF7
5A468CE743940E7A529C86EED296CA41673A87B47D07210A3A74148A7B268A83
8EF961E3CDB11A76201F04FF1F7D94F130E5394BBBFE6A7CEFDDEDEB0E081C4F
E19188E1DAC75E579D22AF1D01AC327E84D1966C9BB490B3181AF2FCE2C5EB7D
6E812F09465E34B0E518092ECE404D1201CFAA4CEC65535AB32B2E7366C1D05F
CE275544AD6DBBB36ABC62976C22FA37240175DE12E93157F7527CFB16A6D765
307F89B4038C84034F154D27984286C56BAFD8D4B2476BD89BE20D38903764A1
964849643A9E1B1D0FFAA6F79A3B180709FC8C37D19152F9B99F98DD697B9DD9
195C8DA56BABF07B0475963E9ECE3C73DDC3F3BD33E8C6BD7DADF7458C3610C2
764986F2C2F6C38DABAF6FB91A4CCF5D2513062A74BE7A615AF599DBAEA605CB
F201624564999021884027096F65191C20F76D668D0B41E4C6A384FDCB4E6D40
DCEC120210CA13AE99AAB8EF4B20D43BCBACC4ECF89E1C4DE46A27BECB625355
E6DD3D993121152E7E74A82AAD27D18847CD91476517A40DEE9230D8597CE276
0E17651195B28CC547809327CA6923C8F915965DE8DC0923125D86D5039BBD58
DCD9CB011ED7D3851B3DA54CC418264D496084F71B59C28E917935F900B876A3
30D3B7C9D4BB8F738CE8E686759EAFE2D3A948E52227F67980C92FC469CC0308
BDBC09FD798F747CE4D2553F6FC92DA11EABFDE2020266DBE41D236C1A2A54A6
03C6F39486550271A75DE67D1303186A29C6856BD1DF8FF537A32D41A235F013
EBCBFF2A1FF568DA6D0B6A64EE7BF60351AC49A8E6CCEF19E4AF3D1CE7256425
6AA1475909C8B8C48463EBB376C406BF6591E6FE5E557934B90585F95A552C43
18EF0BFB01B0A772B1F416185055E367076211C1A34D6B1BF6855C4FF7148E5E
D8CA8A4C9A854BD22826F6A32073495CA295BE6933B1441A825338BDD109A330
CEA0DAF7C5B204EEB92825695B72D147B2124CE24D677FA60B2B187AACD1AF27
CFD2044ECF823F198CDEA9FBA4EC80010966FC750BBD1287E12BB8B613752A6C
8A64B19EEBE1F81EAF5DDBA6A5B619FA40870797CED5DF95FC2241F07D1C079E
5566A272B23DFBD3F96123F0524D9781A60589C0828C8A08FE98C99C2A55EFDB
97B56F3747CA1AFC6943CA70287B8D009485AFF57D957098743A935E3F0EA994
DC152E588303A479D3432312F8E8EF9471F7AA5A5FCE321A3A8E7B5027769EB5
912BC01221F7E1FDD74651DAEEF3AAD4731C3B6B728350843ABC5DD9786D5D9B
4BFF36301C9D89D9E50DCFB5862DDBEBFD368D3F08DD9C414C5AB9D0539A6046
DDDB512666DCD6594737FF7E86D649E6549D62AB9455C29225888F5FD2B9328A
D2924D97B97858FB3508D01F3B77B4D7E451E0226A4B420DC03FB2A2D2262315
9619EA0D0D7F392615CD906C75020B6735B00D620E929FE7696EA51A97C57727
85056ADE27EF12E096870F603F2267173825CAC12F6BD2687A3DE4528C9E61C9
F6B4F70B93A3B5B50143F520C8267213204FF26CC9B2F7C891FD5FDBFFB4994E
CF216FF82A3CFE2702BF89936C68A836D8F3FB9FE88B8A58451110F672C0DA90
2F04027970FF3FB59A39A5092CDE38413EC544BD31F8A199194C8D5D832F3373
487FFA1A2C55E7DDC50A53624347E745919F623D86012B2BCCD4BC637736244A
48A923689FB371B76E99FED552EB1A7D37E41567DDF4958F07CBFD82833297D9
BEC5E381718FE0C9DB9304C54E027D50253EC67BFE723E90E176A1E1CB89194D
0868E003DE18BE594B65D76B12CB5387FA69F268C69F282C0403FA6A577E3056
3355C7BDEA1A57131ADBB0CBB10C683D47000BF21534273011647F694320E280
1DF2ABE3A31291706AD1DB23227CCD9CBA2F020E5938625AD353D4DA1FCD9013
BC830DD9C5B958F98C871E40915252EA75E403F5578042CC624BEF6191519B63
9D87A565BE39F61C37CCCC3B1E68C28821E5B1E91AADF7DAEF175975472DFFC1
B4F9F918905C3794C1E1E059A77BAD6C9F66398463174F4973A8C48D755A6B24
34BCE500F78A24C50F5C37C09CBA9CECF116D943155B532584AED3457A645359
A122A1C767537CFC73FDC49A0255D652B35B7A469AEAEBB4859DC44D001D8365
B6C877DCD97CE1711A3DFCF389F6B690274188DCE72138258FE2EADDF029A785
8D358A85A4BE424923A196FF48E2CBAAAEC4637F79AB9DC059743E29682FB6C8
FCD59F7D9DFF654EC4FF5B5A012DE8E582B0170EFEF25CD19CD4E37363330575
DAB53AB5E95AB262BF6E5BEF784B2FFEB9846C29F9BA02401F2E404F1D405F80
F2B96643B8D0464C4383BAA135A725568E617E94F27992E19B6CD8DFE554B315
C6B061ED286ACC9813E25B9D2D27A1C04D2B8F47B2BB6CCEEE52CF0393E64B42
39C1A9F1A8DD6CEE2CBF3C343E4813483604D0896F1A6BED39042E15ACDBA483
F269691069D8B359599703D50858C7637D0AF87310066954EB133B7A1BFC68C2
7E0637B85DA3C9310C9024E897ED90E3ADC4B74DD3B682C3C75A9A320FF7F875
C5AF501BA426E2818E9B48A1D51C4348335109ED91357137F225A539D2EEAA18
7EFBA3B8A3994B694EE2281BDBB9800E305D49ABCB74DADB32833265402264EC
E6828413009BD7E36DAD065A6869DD7BCDBE782B2971AFCDEB7D6EB100853BCB
D6B2AE6D6CEF288E718B5F60CF8496D390235B2D44D8FBC9A92491D5BD8CE204
8F4BF1ECCD14590677B4FB020D71C1703B96CBC672D60AD1275D4A77D16CA067
BC1B41BD8E9C11AA09E22CE25D70A165C6FAE8B95A0343ABC7BDEE539FC2816D
394A9BDC4E226AAE5CEF8EABE0C39BB066D1BC5DDB4981C490F3C28F97B5382E
EEEBCFFE1ABE1B55D7FCB5888117010D68024C26F81DC1CB798BB13FFCEE2930
16DADC7AF709F4E111F6515F5A718B090643C9DB22DC48BDA527A3A7EEF1C85E
335DFE0EA685AA0F47B446420B3F219204CA43994BFCCB8D65C7D3C4ECC8B1AE
7A7C37172E90D975AF840018E727D9886336B100F561090138D897A538D89D82
DC95A1D511491BAADBE7F0A245759BE1FB6B4CE66638DFA12797355215C6AF02
C14A12418D394A00F1244BCB72B086A48638BFB42CB8071B2586C62EF444F52C
DAAFAB5DE7F13D266D599EF476CCCFCAD28D18DA6369EA5C4EECC58ACE665E72
E3E66F8396CF70657039EC1F6BB0CE69F2FFE8E5FD37C1FCC3B184E4743F33C5
08B017F783C29C3604D09D059CDF5F92E21B6C56546516F64EFFE77BFE2AF010
F9DE44E7D7B01AEA95F2CA5A2C7882233674B30552B1E7F828145DC333A77FFB
B7128F17E3244330D83143145837FB44CE93591BB7FF6A5EDFB01484AF7EA09B
AB0AABD26000181B07587537A2415ADF1F1D6A1125C71ECCABEB95FC93E0DADF
6DD7BC4F4D1D6D7873E872DCCE9F2435898148687C5C96739C3497B58E38DEDD
9F37AAEE8A0237BAC9E0744B501200A6A00B19EED864F1B747BDCD5D559F045F
C9518C9C3CE274EFE7CA5994F7D633D7F20EEA683779153F8DF73FDAB9672192
4EF1C33D6AED291F0B78C207143161CBD49CAE688FAD63CB46D727A6665F3192
87B4CF48B7B043325340E340AB49D96DEC863A68065097408BD04453B4590BF5
7835C2C79E8591EB81282BA7C1BC0730BF399D4F68E24D7FAED43B6C417A05E5
54B81160D7440B63D0B37CF366B627B992CEEC7E12730C8E5B7CACD356944BBF
51C1E7DAB774808E1813780EF84DB5B3BC8322AF990F6C11F1AD747A608849FC
2EA4BD68A3D35EF68C998647536A02C42031F198BC5E11E325B226F49407125B
F72293FA812D804B1AD84DA1CE262C7253F898C0915BB7CA2E0D2F677597F65A
53C3C1D9896EFEB11F5F788391F7B71160E6CEC7B0B61DADB958D6C80CB88B1C
54F5F1E162BEB008B52B28100FDA6AA4E0CB4FC44D77E4B1D174ACB64BE2AF22
F025C7E3ED94EE04AA8AAD5CA76D5F3DFC0C0AA397321FA06760D9FEE553412E
5D5BDF6B04188D10AAB2EA25AAD16EF5C7AD724CEE707A63FEEE7B24ECDD6669
587504ECDC5DEE84CB467AD76C2C39A36CF1002877A5F2F363499119B3493927
E317399A00A343D563AF32FB564D93E6230235314F4215B619E659937256CBAA
92E1751D4E50A274647930E60C817A460AA7F620A252E8DDBFE06E88EF2EB476
3D36C13E3BA587A3669500BC42B868A58E23553311D5DFBC7B0F954496194623
3BFB65EE9BA2772E479DE2FF5132FA244964CE8CE031D2246CAB79E0E6C83BDE
72FF385D523E5A083C3B7AB029187C98445FBCA660CA6CD43A262E9C785EA52B
26532BF06EF31A4368603D6E148D6C7A1F9AB9949D2F4B45296A5548C117BE4B
8C2E2F2A97CFAB74C9EA6736FF060997B3CEDA92D7FAAA23331BD1EF8E354268
3EF0456C3A0D74E8EFF35D7DB57E3DE1B7F93AB953EC4BEC7A100C7CCF070D59
D5A9D35951838F2172447C660843C5B220F72686F3BAF0EB8573FC804919E0E9
43D0CA9A4CCCB636F9CA857B3BEEEBCC2168DAFA6173AAA29F4F6B71F7F0D97F
71A21488C2FF0833DCE808C46BF95B5ACFEF139DFE5B2E8B4EA35401C4BA75FE
9EC168A5255756E23426A07FEA792A34F67D863030B610E41D0FC65803116913
BA49EAA38A1B472AD484D941B797CB9F8B41D84587FD648948A714E8C7FA6343
D7BFA1C90AE7585A82104C3F8FE9C020BFC2685F20AE69B1851140E83015E76D
4DD53CAF39ED63CF34CB9B20A45419759618084363551A6EB2B7D4673B4D2FEF
B5473A070E08ED1AD4B59F7FC8F986475B74A8B721566EC9A7373C3A433E3D9C
2448D878FA41518DBFB8817CEBB6005EA1E8927837F1F8DFC31AE31F8C52AF13
D47BA1A29153ABCAA55EF112D84EBE1389BF73F90974DB38ECD03E32B061AB58
683F2148DEB62D6EDE457638D6ADB3577CEC95FA91BD7EDB77F5CF97C2575D26
987AEA64F7A7BDD7F2606B7F0C9EB3CB07F989498AD7CE1F3708BC405C78D7CE
C2B6113254BA611446C66C03EEEA2F13004E9ECEDB91A6A5580A14083AA07682
6FF48642192F548E8EC37A2A0CDC7CB4F68270599C911DD9AAAD1646904EF093
2E22F4508DE69ADB7DFB91A88BA9A473CA377C3D49290BD75423EC4AB69DD18F
021B48EE118035D03A5753C1CB32448C7C248E8EF6452F91F6FA48F2192E3D5C
91F4737EC22634685B6DB0B301CE76DDA73253683306673314CF4B937A024B8E
D0D2E1B870A49212F8F1603AB24A6C7318D35CAB96EBCF733D3846AA171D5275
B00E05E639D58198D2064EEC57DB3279897A6EB7CF3984A1AEC2940E720BBEB6
4195C931EF1BFC5158239217A0E529415554B8F3F301DE45E0E4BA97C9CD4EF0
6B45D17F5DEE4C3DEEA09F44EBBCC4B0BA175D9F27ABC538C39E1D7BB3377F0C
EA5C37473FACF6B4900D4F5FAB9EECBCCCD582315C41B6B99FD8CD88159C6CDD
64B51D9961CB525EE38561E81791E0D2D1C61E03E0FA77C3EDFF935E65C18161
8998DEE7AD030678930237A74E76C927D52AF3B8F44C84A3F2D786BCE9FEC786
F09BB21E3ED6C8DE8D83841FFAD1AE6A5EB3ADAEBD037218C8D57BBA878A3608
361C230FDEBA9247A37100755EF81D99CCC27D92DB68DD17308B06957496ADDA
BCB03E16C7686C5D7C25F4958C78E01FF95D995115D32C59D5B1A9C530B9962C
48875A4D847CD0A42EE2B02D67E94A00964999B0247FCE100F7E6FD285A1836A
BF940AF47F1678540AC9DD0DE1A3E859D9CDC36C0DBED1903B7A20FA6E281F0A
F5041AFD49C67712AC67708E2D5459341E403B364E5A518FA2C69B274EE5B619
B9BD45E6D0F27E0064BDBE78BFCB6DC5784CDF4A033BEE69BA83317693784450
965D605C180892D2D03115A73C06F3F2671CE57F9A84C22BA6BD9DC100F9A749
4390D0B6052F72356A684CBFA65A855C0692E8505BBB05D4A5144118A52F0C2D
DDEB73A7BE241809A1D12479555688B512D9992DD2665B1827A172F61EF8625E
27D63C50A392AA403AA2D2A0B076D2B3720BE68E57CBC0EDD8A572C338A4288B
E366026818F8A6F64740617625D27B2108BBB030B1749EBBA9CCE8F605F8531B
05380DBD79B1AA4E215A9C2A714044914E511FFDF465E7D273E0F3E0D6A756F8
633860CA31915AD8A0EB7B30EA0D4443A64C2F60D3AA0E84DC8B43359C3FD236
EE0F90A27CEA0E41382A3B436059DB5F0A7CCC1154B505D7CC9D9F22A3206A47
36B34237A18EF1EB287E36D0C4FAF0A63818047BBB9678552E6620A1A410F8A6
B471B2ECF611AE209489B9D43725E609CD96BD88D1C56F2174BC7F0E79DEC3AE
A9AF6F6711E405662068771DB5355DCE272898C453FBFD6066725CD85D7C3288
E61CE0CAA33A6DA9086606E27F6A782FDE1BBF953F94BEACAC79DCFA996EA316
591A364DEE036765A139ECDEB51258323F72426FE2E36E8719676A80A89E0737
2714BEC00A44AB33F9A5431D6A9DC14365E9D7EF309B814FF6EDA2D3ED24A214
2E1AB8A7EE58EF7B5FA7158B3C0CD89F4632C9B97D98B34A99A20ED1E03E7523
4DDED7E30057DE28F6857611F3CEEEB36CF19B5ADBCFE8782EE7AD8117AA6781
3D4B625D44BF1F05ACE4EA0799DBE7AA7DB917521BB78AF61FF7268AAD181A50
CB4DB1BD7733BEB3DD2EF3E96171CB986BAE1308B6A38F55EB875BD67F1B907A
90FB092B61F5A56C2025F7F8C0D12BF6DFB962920C77B02C387E9DAF9AB489F3
284DDD4BAFD0EF3A8E85778C99899E7B8B38A94DF512C716AA3F4A4596238175
E2F322EF645CCEBD3E2D4176D3ED904F7B89EB9AF7DE8AEA702FC5B765552F78
058A20E424277F667A4E9955A797593CE44E19A98F149CA17D6379040A1C836C
A18234278DFDA205EFD55D527C7F38766D4C97
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 39158280 55380996 1000 600 600 (test.dvi)
@start /Fa 133[37 4[46 2[33 2[42 46 3[25 4[37 2[46 48[42
49[{ T1Encoding ReEncodeFont }9 83.022 /SFRM1000 rf /Fb
139[51 52 3[66 73 4[37 3[60 1[58 48[66 50[{ T1Encoding ReEncodeFont }8
119.552 /SFBX1440 rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: a4
/setpagedevice where
{ pop << /PageSize [595 842] >> setpagedevice }
{ /a4 where { pop a4 } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 515 440 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def

515 440 a 515 440 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 515 440 a 515 440 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 515 440 a 0 TeXcolorgray
83 x Fb(test)43 b(section)639 1369 y
tx@Dict begin CP CP translate 1.0  1.0  scale NET  end
 639 1369 a 667 991
a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 1.13791 SLW 0  setgray   0. true 91.04869 45.52455 0.0 -45.52455 .5
Frame  gsave 1.13791 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 667 991 a
tx@Dict begin { 11.38092 34.1432 } PutCoor PutBegin  end
 667
991 a -16 x Fa(b)r(onjour)667 991 y
tx@Dict begin  PutEnd  end
 667 991 a 667 991
a
tx@Dict begin { 34.1432 22.76227 } PutCoor PutBegin  end
 667 991 a Fa(rez)667 991 y
tx@Dict begin  PutEnd  end
 667 991 a 667 991 a
tx@Dict begin { 45.52455 11.38092 } PutCoor PutBegin  end
 667
991 a Fa(rezrez)667 991 y
tx@Dict begin  PutEnd  end
 667 991 a 667 991 a
tx@Dict begin { 34.1432 0.0 } PutCoor PutBegin  end
 667 991
a Fa(rez)667 991 y
tx@Dict begin  PutEnd  end
 667 991 a 667 991 a
tx@Dict begin { 45.52455 -22.76227 } PutCoor PutBegin  end
 667 991 a Fa(zer)667
991 y
tx@Dict begin  PutEnd  end
 667 991 a 667 991 a
tx@Dict begin { 34.1432 -11.38092 } PutCoor PutBegin  end
 667 991 a Fa(rez)667 991 y
tx@Dict begin  PutEnd  end

667 991 a 639 1369 a
tx@Dict begin  CP CP translate 1 1.0 div 1 1.0 div scale NET  end
 639 1369 a 515 1644 a Fb(test)g(2)639
3723 y
tx@Dict begin CP CP translate 1.0  1.0  scale NET  end
 639 3723 a 667 2729 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 1.13791 SLW 0  setgray   239.00287 -85.07343 2 copy moveto 34.1432
.5 CLW mul sub dup 0 rmoveto 0 360 arc closepath  gsave 1.13791 SLW
0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke
 grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 1.13791 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [
147.95418 -85.07343 147.95418 -85.07343 147.95418 -85.07343 147.95418
-85.07343 204.85966 -85.07343    /Lineto /lineto load def 0  setlinejoin
false Line  gsave 1.13791 SLW 0  setgray  1. .setopacityalpha   0 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 1.13791 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [
330.05199 -85.07343 330.05199 -85.07343 273.1465 -85.07343    /Lineto
/lineto load def 0  setlinejoin false Line  gsave 1.13791 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 1.13791 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [
136.57324 -73.69249 113.81097 -50.9302 147.95418 -85.07343    /Lineto
/lineto load def 0  setlinejoin false Line  gsave 1.13791 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 1.13791 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [
125.1919 -107.8357 113.81097 -119.21663 147.95418 -85.07343    /Lineto
/lineto load def 0  setlinejoin false Line  gsave 1.13791 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 1.13791 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [
341.43292 -73.69249 364.19519 -50.9302 330.05199 -85.07343    /Lineto
/lineto load def 0  setlinejoin false Line  gsave 1.13791 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 1.13791 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def  [
364.19519 -119.21663 364.19519 -119.21663 330.05199 -85.07343    /Lineto
/lineto load def 0  setlinejoin false Line  gsave 1.13791 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
639 3723 a
tx@Dict begin  CP CP translate 1 1.0 div 1 1.0 div scale NET  end
 639 3723 a 0 TeXcolorgray 1926 5255 a Fa(1)p
0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
